{#
  Domain specification
  Read more about fields and their meaning here:
  https://libvirt.org/formatdomain.html
#}

<domain type='{{ libvirt_guest__domain_type }}'>

  <name>{{ libvirt_guest__hostname }}</name>
  {#
    TODO: allow custom units or swithc to smth. handy
    - "b" or "bytes" for bytes,
    - "KB" for kilobytes (103 or 1,000 bytes),
    - "k" or "KiB" for kibibytes (1024 bytes),
    - "MB" for megabytes (106 or 1,000,000 bytes),
    - "M" or "MiB" for mebibytes (220 or 1,048,576 bytes),
    - "GB" for gigabytes (109 or 1,000,000,000 bytes),
    - "G" or "GiB" for gibibytes (230 or 1,073,741,824 bytes),
    - "TB" for terabytes (1012 or 1,000,000,000,000 bytes),
    - "T" or "TiB" for tebibytes (240 or 1,099,511,627,776 bytes).
  #}
  {% set memory_unit = libvirt_guest__memory_unit | default("KiB") %}
  <memory unit='{{ memory_unit }}'>{{ libvirt_guest__memory }}</memory>
  {# TODO: add maxMemory and currentMemory (?) #}
  <vcpu placement='static'>{{ libvirt_guest__cpus }}</vcpu>
  <resource>
    <partition>/machine</partition>
  </resource>
  <os>
    <type arch='x86_64' machine='{{ libvirt_guest__os_machine }}'>hvm</type>
{% for dev in libvirt_guest__boot_devices %}
    <boot dev='{{ dev }}'/>
{% endfor %}
  </os>
  <features>
    <acpi/>
    <apic/>
    <vmport state='off'/>
  </features>
  {#
    libvirt will automagically fill-in CPU model and features (which are crucial
    for nested VBox) based on host CPU.
  #}
  <cpu mode='host-model'>
    <model fallback='allow'/>
  </cpu>
  
  <!--
  TODO: this is legacy config used before vbox-in-kvm
  It's kept as reference temporarily and should be removed after testing
  VBox works a bit differently and needs host-model cpu features which appear
  dynamically once VM started.
  date: 28.03.2018
  <cpu mode='custom' match='exact'>
    <model fallback='forbid'>{{ libvirt_guest__cpu_model | default("Broadwell") }}</model>
  </cpu>
  -->
  {# TODO Windows wants offset='localtime' #}
  <clock offset='utc'>
    <timer name='rtc' tickpolicy='catchup'/>
    <timer name='pit' tickpolicy='delay'/>
    <timer name='hpet' present='no'/>
  </clock>
  <on_poweroff>destroy</on_poweroff>
  <on_reboot>restart</on_reboot>
  <on_crash>restart</on_crash>
  <pm>
    <suspend-to-mem enabled='no'/>
    <suspend-to-disk enabled='no'/>
  </pm>

  <devices>
    <emulator>/usr/bin/qemu-kvm</emulator>

{% if libvirt_guest__graphics is defined and libvirt_guest__graphics == true %}
    <graphics type='spice' autoport='yes'>
      <listen type='address'/>
    </graphics>
{% endif %}

{% for disk in libvirt_guest__disks_final %}
  {# Type of disk: file|block|dir|network|volume #}
  {# Only files are supported for now #}
  {% set disk_type   = "file" %}
  {# Disk device: floppy|disk(default)|cdrom|lun #}
  {% set disk_device = disk.device | default("disk")%}
  {# Driver name + type, for example:
     xen:  tap|tap|phy|file + aio
     qemu: qemu + raw|bochs|qcow2|qed #}
  {% set driver_name = "qemu" %}
  {% set driver_type = disk.driver_type %}

  {% set source_file = disk.source_file %}
  {# optional "ide", "scsi", "virtio", "xen", "usb", "sata", or "sd" #}
  {% set target_bus  = disk.target_bus %}
  {# "logical" device name, (!) exact mount is not guaranteed #}
  {# TODO: calc last letter independently for target buses #}
  {% set target_dev  = {
      "virtio": "vd",
      "sata"  : "sd",
      "scsi"  : "sd",
      "sd"    : "sd",
      "ide"   : "hd",
      "fdc"   : "fd",
    }[ target_bus | lower ] ~ "abcdefghijklmnopqrstuvwxyz"[loop.index0] %}
  {% set readonly    = disk.readonly is defined and disk.readonly == true %}
  {% set tray_is_open= disk.source_file is not defined %}
  {# When disk is represented as file on host #}
  {% if disk_type == "file" %}
    <disk type='{{ disk_type }}' device='{{ disk_device }}'>
      {# FIXME this is a workaround for floppy, it definetely has some driver #}
      <driver name='{{ driver_name }}' type='{{ driver_type }}'/>
      {% if not tray_is_open %}
      <source file='{{ source_file }}'/>
      {% endif %}
      <target
        dev='{{ target_dev }}'
        bus='{{ target_bus }}'
        {% if tray_is_open %}
        tray='open'
        {% endif %}
        />
    {% if readonly %}
      <readonly/>
    {% endif %}
    </disk>
  {% endif %}

{% endfor %}

{% for network in networks %}
  {# Only bridges for now #}
  {% set source_mode      = "bridge" %}
  {% set source_dev       = network.source_dev %}
  {% set model_type       = network.model_type | default("e1000") %}
  {% set address_domain   = 0 %}
  {% set address_bus      = 0 %}
  {% set address_slot     = network.address_slot %}
  {% set address_function = 0 %}
    <interface type='direct'>
      <source dev='{{ source_dev }}' mode='{{ source_mode }}'/>
      <model type='{{ model_type }}'/>
      {# mask for vals: domain=0x0000 bus=0x00 slot=0x00 function=0x0 #}
      <address
        type='pci'
        domain='{{    "%#0.4x" | format(address_domain)   }}'
        bus='{{       "%#0.2x" | format(address_bus)      }}'
        slot='{{      "%#0.2x" | format(address_slot)     }}'
        function='{{  "%#0.1x" | format(address_function) }}'/>
    </interface>
{% endfor %}

    <console type='pty'>
      <target type='serial' port='0'/>
    </console>

  </devices>

</domain>
