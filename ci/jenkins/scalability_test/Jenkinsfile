
// DIST_HOST = 'demo'
DIST_HOST = ''  // local for burbank jenkins
NX_REPOSITORY_CREDENTIALS_ID = 'nx-repository-readonly'
JENKINS_SRC_DIR = 'devtools/ci/jenkins/scalability_test'
JUNK_SHOP_SRC_DIR = 'devtools/ci/junk_shop'
JUNK_SHOP_HOST = '10.1.5.105'
JUNK_SHOP_CREDENTIALS_ID = 'junk_shop_db'
JUNK_SHOP_PROJECT = 'scalability'
PLATFORM = 'linux-x64'
DEFAULT_MERGE_TIMEOUT = '1h'
WORKER_HOST_LIST = ['scalability2', 'scalability3']  // ssh names
DEFAULT_LWS_SERVER_COUNT = '50, 100, 150, 200, 250'
DEFAULT_FULL_SERVER_COUNT = '20, 40, 60, 80, 100'
CAMERAS_PER_SERVER = 20
USERS_PER_SERVER = 4
PROPERTIES_PER_CAMERA = 5


def main() {
	def upstream_ci_project_name = env.UPSTREAM_CI_PROJECT_NAME
	def upstream_ci_branch = env.UPSTREAM_CI_BRANCH
	echo "Upstream project: $upstream_ci_project_name"
	echo "Branch: $upstream_ci_branch"
	assert upstream_ci_project_name, 'UPSTREAM_CI_PROJECT_NAME must be injected using properties'
	assert upstream_ci_branch, 'UPSTREAM_CI_BRANCH must be injected using properties'

	def build_to_test = null  // [customization: 'default', path: '/...', branch: 'dev_3.1_dev', build: 12345, version: '3.1.0.12345']
	def action = params?.action ?: 'update_parameters'
	def must_clean_workspace = params?.clean ?: false
	def is_p2p_mode = params?.p2p_mode ?: true
	def use_lightweight_servers = params?.use_lightweight_servers ?: 'both'
	def server_count_list = [
		lws: params?.lws_server_count ?: DEFAULT_LWS_SERVER_COUNT,
		full: params?.full_server_count ?: DEFAULT_FULL_SERVER_COUNT,
		]
	def test_params = [
		merge_timeout: params?.merge_timeout ?: DEFAULT_MERGE_TIMEOUT,
		cameras_per_server: CAMERAS_PER_SERVER,
		users_per_server: USERS_PER_SERVER,
		properties_per_camera: PROPERTIES_PER_CAMERA,
		]

	stage('Load package') {
		node ('master') {
			echo '============================================================'
			echo "Started $action"
			build_to_test = load_distributive_stage(
				upstream_ci_project_name, upstream_ci_branch, must_clean_workspace, params?.build_to_test)
		}
	}

	if (action != 'update_parameters') {
		node('scalability-test') {
			scalability_test_stages(must_clean_workspace, is_p2p_mode, use_lightweight_servers, build_to_test, server_count_list, test_params)
		}
	}
}

def load_distributive_stage(upstream_ci_project_name, upstream_ci_branch, must_clean_workspace, build_to_test_param) {
	if (must_clean_workspace) {
		echo "Cleaning workspace ${pwd()}"
		deleteDir()
	}
	dir ('devtools') {
		checkout scm
	}

	def build_list = load_build_list()
	update_job_parameters(build_list)

	switch(action) {
		case 'test_release':
			def build_to_test = pick_release_build_by_param(build_to_test_param)
			stash_release_distributive(build_to_test)
			return build_to_test
		case 'test_ci':
			def build_to_test = stash_ci_distributive(upstream_ci_project_name, upstream_ci_branch)
			return build_to_test
		default:
			for (build in build_list) {
				echo "Loaded build: $build"
			}
	}
}

def scalability_test_stages(must_clean_workspace, is_p2p_mode, use_lightweight_servers, build_to_test, server_count_list, test_params) {
	echo "Will test build $build_to_test"

	stage('Prepare test environment') {
		prepare_test_environment(must_clean_workspace, is_p2p_mode)
	}
	if (use_lightweight_servers in ['yes', 'both']) {
		run_tests_stage('with lws', build_to_test, server_count_list.lws, test_params + [use_lightweight_servers: true])
	}
	if (use_lightweight_servers in ['no', 'both']) {
		run_tests_stage('without lws', build_to_test, server_count_list.full, test_params + [use_lightweight_servers: false])
	}
}

def run_tests_stage(stage_desc, build_to_test, server_count_list, test_params) {
	stage("Run tests $stage_desc") {
		echo ("Will test version $build_to_test.version customization $build_to_test.customization"
			+ " $stage_desc with server counts $server_count_list and params $test_params:")
		def workspace_dir = pwd()
		for (server_count in split_int_list(server_count_list)) {
			run_test(workspace_dir, build_to_test, test_params + [server_count: server_count])
		}
	}
}

// Change parameters for currently running jenkins task; next run will require and use these parameters.
def update_job_parameters(build_list) {
	def job_params = [
		choice(name: 'action', choices: ['test_ci', 'test_release', 'update_parameters'].join('\n'),
			description: 'Action to run'),
		[$class: 'BuildSelectorParameter',
			defaultSelector: [$class: 'StatusBuildSelector', stable: true],
			description: 'Which kind of latest CI build to test',
			name: 'artifact_source'],
		choice(name: 'build_to_test', choices: build_list.join('\n'), description: 'Build to test, <branch>-<build-num>-<customization>'),
		booleanParam(name: 'clean', defaultValue: false, description: 'Start from clean workspace'),
		string(name: 'lws_server_count', defaultValue: DEFAULT_LWS_SERVER_COUNT,
			description: 'How many servers to create and merge when running tests with lightweight servers.'
					   + ' Use multiple values "10, 20, 30" to run test multiple times'),
		string(name: 'full_server_count', defaultValue: DEFAULT_FULL_SERVER_COUNT,
			description: 'How many servers to create and merge when running tests with full mediaservers.'
					   + ' Use multiple values "10, 20, 30" to run test multiple times'),
		string(name: 'merge_timeout', defaultValue: DEFAULT_MERGE_TIMEOUT,
			description: 'Timeout for servers merge, in format: 2h, 30m, 50s'),
		booleanParam(name: 'p2p_mode', defaultValue: true, description: 'Turn p2p mode on/off'),
		choice(name: 'use_lightweight_servers', choices: ['both', 'yes', 'no'].join('\n'),
			description: 'Use lightweight servers from appserver2_ut test; "both" means run both variants'),
	]
	properties([parameters(job_params)])
}

def stash_release_distributive(build_to_test) {
	echo "Will test release distributive $build_to_test"
	sh "mkdir -p dist"
	sh "rm dist/* || true"  // clean distributive from previous build
	if (DIST_HOST)
		sh "scp ${DIST_HOST}:$build_to_test.path dist/"
	else
		sh "cp $build_to_test.path dist/"
	stash includes: 'dist/*', name: 'distributive'
}

def stash_ci_distributive(upstream_ci_project_name, upstream_ci_branch) {
	sh "mkdir -p dist"
	sh "rm dist/* || true"  // clean distributive from previous build
	step([$class: 'CopyArtifact',
			fingerprintArtifacts: true,
			flatten: true,
			projectName: upstream_ci_project_name,
			selector: [$class: 'StatusBuildSelector', stable: false],
			target: 'dist'])
	def file_list = findFiles glob: 'dist/*server*.deb, dist/appserver2_ut'
	def dist_path_list = file_list.findAll{ it =~ /\.deb$/ }
	assert dist_path_list.size() == 1, dist_path_list
	def dist_path = dist_path_list[0]
	def dist_info = parse_dist_path(dist_path)
	stash includes: "$dist_path, dist/appserver2_ut", name: 'distributive'
	return [
		branch: upstream_ci_branch,
		build: dist_info.build,
		version: dist_info.version,
		customization: 'default',
		path: null,
	]
}

def prepare_test_environment(must_clean_workspace, is_p2p_mode) {
	def ws_dir = pwd()
	if (must_clean_workspace) {
		echo "Cleaning workspace $ws_dir"
		deleteDir()
	}
	dir ('devtools') {
		checkout scm
	}

	sh 'if [ -d dist ]; then rm -rf dist; fi'  // clean distributive from previous build
	unstash 'distributive'
	sh 'mkdir -p bin work/test'
	sh "ln -sf $ws_dir/dist/*.deb bin/mediaserver.deb"  // we expect only one .deb in distributives
	sh "ln -sf $ws_dir/dist/appserver2_ut bin/"
	checkout([
			$class: 'MercurialSCM',
			credentialsId: NX_REPOSITORY_CREDENTIALS_ID,
			installation: '(Default)',
			revision: 'vms_3.1',
			source: 'ssh://hg@la.hdw.mx/nx_vms',
			subdir: 'nx_vms',
		])
	sh 'if [ -d work/venv ]; then rm -rf work/venv; fi'
	sh 'virtualenv --system-site-packages work/venv'
	sh './work/venv/bin/pip install -r nx_vms/func_tests/requirements.txt'
	sh "./work/venv/bin/pip install -r $JUNK_SHOP_SRC_DIR/requirements.txt"
	write_p2p_flag(is_p2p_mode)
}

def write_p2p_flag(is_p2p_mode) {
	def path = '/tmp/appserver2.ini'
	writeFile file: path, text: "isP2pMode = ${is_p2p_mode ? 1 : 0}\n"
	for (host in WORKER_HOST_LIST) {
		sh "scp $path $host:$path"
	}
}

def run_test(ws_dir, build_to_test, test_params) {
	echo "Running test with server count $test_params.server_count:"
	def build_parameters = [
		"project=$JUNK_SHOP_PROJECT",
		"branch=$build_to_test.branch",
		"version=$build_to_test.version",
		"platform=$PLATFORM",
		"customization=$build_to_test.customization",
	]
	def run_parameters = test_params.collect { it -> "$it.key=$it.value" }
	def test_parameters = test_params.collect { it -> "scalability_test.$it.key=$it.value" }
	def options = [
		"--work-dir=$ws_dir/work/test",
		"--bin-dir=$ws_dir/bin",
		"--reinstall",
		"--customization=$build_to_test.customization",
		"--nocapturelog",
		"--capture-db=\$junk_shop_credentials@$JUNK_SHOP_HOST",
		"--build-parameters=${build_parameters.join(',')}",
		"--run-parameters=${run_parameters.join(',')}",
		"--test-parameters=${test_parameters.join(',')}",
		"--tests-config-file=$ws_dir/$JENKINS_SRC_DIR/test-config.yaml",
	]
	dir('nx_vms/func_tests') {
		withEnv(["PYTHONPATH+X=$ws_dir/$JUNK_SHOP_SRC_DIR",
				"PYTEST_PLUGINS=junk_shop.pytest_plugin"]) {
			withCredentials([usernameColonPassword(
						credentialsId: JUNK_SHOP_CREDENTIALS_ID,
						variable: 'junk_shop_credentials')]) {
				sh ". $ws_dir/work/venv/bin/activate && pytest ${options.join(' ')} scalability_test.py"
			}
		}
	}
}


// utilities ====================================================================

def pick_release_build_by_param(build_to_test_param) {
	def l = build_to_test_param.tokenize('-')
	def branch = l[0]
	def build = l[1]
	def customization = l[2]

	def output = sh script: "./$JENKINS_SRC_DIR/pick-build-path.sh '$DIST_HOST' $build $branch $customization", returnStdout: true
	def path = output.trim()
	assert !path.contains('\n')  // only one distributive expected to be found
	def version = parse_dist_path(path).version
	return [
		branch: branch,
		build: build,
		version: version,
		customization: customization,
		path: path,
	]
}

def load_build_list() {
	def output = sh script: "./$JENKINS_SRC_DIR/list-builds.sh $DIST_HOST", returnStdout: true
	return match_builds(output)
}

def match_builds(findOutput) {
	def mo = findOutput =~ '/((\\d+)\\-([^/]+)/([^/]+)/.+\\.deb)'
	def builds = []
	for (match in mo) {
		def branch = match[3]
		def build = match[2]
		def customization = match[4]
		//println "branch: ${branch}, build: ${build}, customization: ${customization}, path: ${match[1]}"
		builds << "${branch}-${build}-${customization}"
	}
	return builds
}

def parse_dist_path(path) {
	def mo = path =~ '/.+-server-(([0-9]\\.){3}([0-9]+))-linux64.*.deb'
	return [
		version: mo[0][1],
		build: mo[0][3].toInteger(),
		]
}

// Move to separate function to avoid java.io.NotSerializableException: java.util.AbstractList$Itr
def split_int_list(value) {
	return (value.split(/[, ]+/)) as ArrayList
}


// ==============================================================================
main()
// ==============================================================================
