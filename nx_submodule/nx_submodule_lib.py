#!/usr/bin/env python3

## Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/

import dataclasses
from pathlib import Path
import shutil
import subprocess
import tempfile
from typing import Optional


class NxSubmoduleError(RuntimeError):
    pass


class NxSubmoduleMultipleRemotesError(NxSubmoduleError):
    def __init__(self, remote_urls: list[str]):
        self.remote_urls = remote_urls


class NxSubmoduleDirectoryError(NxSubmoduleError):
    pass


class NxSubmoduleConfigError(NxSubmoduleError):
    pass


class NxSubmoduleUpdateError(NxSubmoduleError):
    pass


@dataclasses.dataclass(frozen=True)
class NxSubmoduleConfig:
    subrepo_url: str
    subrepo_dir: str
    commit_sha: str = None
    git_ref: str = None

    CONFIG_FILE_NAME = "_nx_submodule"

    def __post_init__(self):
        if not self.commit_sha and not self.git_ref:
            raise NxSubmoduleConfigError(
                "ERROR: Either 'commit_sha' or 'git_ref' parameter must be specified.")
        if not self.git_ref:
            object.__setattr__(self, "git_ref", self.commit_sha)

    @classmethod
    def load_from_dir(self, dir: Path):
        config_file = dir / self.CONFIG_FILE_NAME
        if not config_file.exists():
            raise NxSubmoduleConfigError(
                f"ERROR: Submodule config file {config_file.as_posix()!r} does not exist.")

        config_data = {}
        with open(config_file) as config:
            for line in config.readlines():
                line_stripped = line.strip()
                if not line_stripped or line_stripped.startswith("#"): continue
                file_key, _, value = line_stripped.partition("=")
                object_key = file_key.strip().replace("-", "_")
                config_data[object_key] = value.strip()

        try:
            result = NxSubmoduleConfig(**config_data)
        except TypeError:
            error = NxSubmoduleConfigError(
                f"ERROR: Nx submodule config file {config_file.as_posix()!r} has wrong format.")
            raise error from None

        return result

    def save_to_dir(self, dir: Path):
        with open(dir / self.CONFIG_FILE_NAME, "w") as config:
            config.write("# This file is autogenerated.\n")
            for key, value in dataclasses.asdict(self).items():
                file_key = key.replace("_", "-")
                config.write(f"{file_key}={value}\n")

    @classmethod
    def resolve(cls, repo_dir: Path, config: 'NxSubmoduleConfig') -> 'NxSubmoduleConfig':
        git_ref = config.git_ref if config.git_ref else config.commit_sha
        return cls(
            subrepo_url=config.subrepo_url,
            subrepo_dir=config.subrepo_dir,
            git_ref=git_ref,
            commit_sha=_resolve_git_ref(normalized_dir_name=repo_dir.as_posix(), git_ref=git_ref))


def get_repo_url_by_local_dir(dir: Path) -> str:
    normalized_dir_name = dir.as_posix()
    git_get_remotes_run_result = subprocess.run(
        ["git", "-C", normalized_dir_name, "remote"], capture_output=True)
    if git_get_remotes_run_result.returncode != 0:
        raise NxSubmoduleError(
            f"ERROR: Failed to obtain remotes list from {normalized_dir_name!r} directory: "
            f"{git_get_remotes_run_result.stderr!r}.")

    remotes = git_get_remotes_run_result.stdout.decode("ascii").strip().split("\n")
    if len(remotes) != 1:
        remote_urls = [_get_remote_url(normalized_dir_name, r) for r in remotes]
        raise NxSubmoduleMultipleRemotesError(remote_urls)

    repo_url = _get_remote_url(normalized_dir_name, "origin")

    return normalize_git_repo_url(repo_url)


def _resolve_git_ref(normalized_dir_name: str, git_ref: str) -> str:
    print(repr(["git", "-C", normalized_dir_name, "rev-parse", git_ref]))
    git_resolve_ref_run_result = subprocess.run(
        ["git", "-C", normalized_dir_name, "rev-parse", git_ref], capture_output=True)
    if git_resolve_ref_run_result.returncode != 0:
        raise NxSubmoduleError(
            f"ERROR: Failed to resolve Git reference {git_ref!r}: "
            f"{git_resolve_ref_run_result.stderr!r}.")

    sha = git_resolve_ref_run_result.stdout.decode('ascii').strip()
    if "\n" in sha:
        raise NxSubmoduleError(
            f"ERROR: Failed to resolve Git reference {git_ref!r};  "
            f"unexpected output from {git_resolve_ref_run_result.args!r} command: unexpected "
            f"output from {git_resolve_ref_run_result.args!r} command: "
            f"{git_resolve_ref_run_result.stdout!r}.")

    return sha


def _get_remote_url(normalized_dir_name: str, remote: str) -> str:
    git_get_url_run_result = subprocess.run(
        ["git", "-C", normalized_dir_name, "remote", "get-url", remote], capture_output=True)
    if git_get_url_run_result.returncode != 0:
        raise NxSubmoduleError(
            f"ERROR: Failed to obtain sub-repository URL from {normalized_dir_name!r} directory: "
            f"{git_get_url_run_result.stderr!r}.")

    repo_url = git_get_url_run_result.stdout.decode('ascii').strip()
    if "\n" in repo_url:
        raise NxSubmoduleError(
            f"ERROR: Failed to obtain sub-repository URL from {normalized_dir_name!r} directory; "
            f"unexpected output from {git_get_url_run_result.args!r} command: "
            f"{git_get_url_run_result.stdout}.")

    return repo_url


def normalize_git_repo_url(repo_url: str) -> str:
    repo_url_with_user = f"git@{repo_url}" if "@" not in repo_url else repo_url
    repo_url_has_suffix = not repo_url_with_user.endswith(".git")
    full_repo_url = f"{repo_url_with_user}.git" if repo_url_has_suffix else repo_url_with_user
    return full_repo_url.strip()


def create_submodule(dir: Path, repo_url: str, repo_dir: str, git_ref: str):
    if dir.exists():
        raise NxSubmoduleDirectoryError(f"ERROR: The directory {dir.as_posix()!r} already exists.")
    config = NxSubmoduleConfig(subrepo_url=repo_url, subrepo_dir=repo_dir, git_ref=git_ref)
    resolved_config = _update_or_create_submodule(submodule_dir=dir, config=config)
    print(
        f"=== Nx submodule was created in directory {dir.as_posix()!r} for URL {repo_url!r}, "
        f"subdirectory {repo_dir!r}, pointing at commit {resolved_config.commit_sha!r}"
        f"{resolved_config.git_ref!r}.")


def _update_or_create_submodule(
        submodule_dir: Path, config: NxSubmoduleConfig, fetch_url=None) -> NxSubmoduleConfig:
    repo_url = fetch_url if fetch_url else config.subrepo_url

    with tempfile.TemporaryDirectory() as tmp_dir_name:
        subprocess.run(["git", "clone", repo_url, tmp_dir_name])
        resolved_config = NxSubmoduleConfig.resolve(repo_dir=Path(tmp_dir_name), config=config)
        git_reset_run_result = subprocess.run(
            ["git", "-C", tmp_dir_name, "reset", "--hard", resolved_config.commit_sha])
        if git_reset_run_result.returncode != 0:
            raise NxSubmoduleUpdateError(
                f"ERROR: Failed to update Nx Submodule with URL {resolved_config.subrepo_url!r} "
                f"in directory {submodule_dir.as_posix()!r}.")

        if submodule_dir.exists():
            shutil.rmtree(submodule_dir)

        subrepo_dir = Path(resolved_config.subrepo_dir)
        if subrepo_dir.is_absolute():
            error = NxSubmoduleConfigError(
                f"ERROR: `subrepo_dir` parameter must not be an absolute path.")
            raise error from None

        shutil.copytree(
            Path(tmp_dir_name) / subrepo_dir,
            submodule_dir,
            ignore=shutil.ignore_patterns(NxSubmoduleConfig.CONFIG_FILE_NAME, ".git"))

    resolved_config.save_to_dir(submodule_dir)
    return resolved_config


def update_submodule(
        dir: Path,
        git_ref: Optional[str] = None,
        repo_url: Optional[str] = None,
        fetch_url: Optional[str] = None) -> bool:
    config = NxSubmoduleConfig.load_from_dir(dir)

    if repo_url and config.subrepo_url != repo_url:
        print(
            f"=== Nx submodule in directory {dir.as_posix()!r} has URL {config.subrepo_url!r} and "
            f"is not selected for update. Skipping.")
        return False

    if git_ref == config.commit_sha:
        print(
            f"=== Nx submodule in directory {dir.as_posix()!r} is already pointing at commit "
            f"{config.commit_sha!r} Skipping.")
        return False

    updated_config = NxSubmoduleConfig(
        subrepo_url=config.subrepo_url,
        subrepo_dir=config.subrepo_dir,
        git_ref=git_ref or config.git_ref)

    resolved_updated_config = _update_or_create_submodule(
        submodule_dir=dir, config=updated_config, fetch_url=fetch_url)

    print(
        f"=== Nx submodule in directory {dir.as_posix()!r} was successfully updated and now is "
        f"pointing at commit {resolved_updated_config.commit_sha!r} "
        f"({resolved_updated_config.git_ref!r}).")
    return True


def find_and_update_submodules(
        main_repo_dir: Path,
        git_ref: Optional[str],
        repo_url: Optional[str],
        fetch_url: Optional[str]):
    for dir in main_repo_dir.rglob("*"):
        if is_nx_submodule_dir(dir):
            update_submodule(
                dir=dir, git_ref=git_ref, repo_url=repo_url, fetch_url=fetch_url)


def is_nx_submodule_dir(dir: Path) -> bool:
    if not dir.is_dir():
        return False
    return (dir / NxSubmoduleConfig.CONFIG_FILE_NAME).is_file()
