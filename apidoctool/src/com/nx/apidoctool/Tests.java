package com.nx.apidoctool;

import com.nx.apidoc.Apidoc;
import com.nx.util.SourceCodeEditor;
import com.nx.util.TestBase;
import com.nx.util.Utils;
import com.nx.util.XmlUtils;
import org.w3c.dom.Document;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.Properties;

public final class Tests
    extends TestBase
{
    private void readTestProperties()
    {
        Properties properties = new Properties();
        try
        {
            InputStream input = new FileInputStream(testPropertiesFile);
            try
            {
                properties.load(input);
            }
            finally
            {
                input.close();
            }

            expectedProcessedFunctionsCount = Integer.valueOf(
                properties.getProperty("functions_count_SystemApi"));
        }
        catch (Throwable e)
        {
            System.err.println("");
            System.err.println("FATAL ERROR: Unable to read " + testPropertiesFile + ": "
                + e.getMessage());
            System.exit(2);
        }
    }

    private static void apiXmlToXml(File inputApiXmlFile, File outputApiXmlFile)
        throws Exception
    {
        final Document document = XmlUtils.parseXmlDocument(inputApiXmlFile);
        final Apidoc apidoc = new Apidoc();
        apidoc.readFromDocument(document);
        final Document outputDocument = apidoc.toDocument();
        XmlUtils.writeXmlDocument(outputDocument, outputApiXmlFile);
    }

    //--------------------------------------------------------------------------

    private void testXml()
        throws Exception
    {
        final File outputXmlFile = Utils.insertSuffix(apiXmlFile, ".TEST");
        final File newOutputXmlFile = Utils.insertSuffix(apiXmlFile, ".TEST2");

        apiXmlToXml(apiXmlFile, outputXmlFile);
        checkFileContentsEqual(apiXmlFile, outputXmlFile);

        apiXmlToXml(outputXmlFile, newOutputXmlFile);
        checkFileContentsEqual(outputXmlFile, newOutputXmlFile);

        outputXmlFile.delete();
        newOutputXmlFile.delete();
    }

    private void testSourceCode()
        throws Exception
    {
        final File outputCppFile = Utils.insertSuffix(cppFile, ".TEST");

        SourceCodeEditor sourceCodeEditor = new SourceCodeEditor(cppFile);

        sourceCodeEditor.saveToFile(outputCppFile);
        TestBase.checkFileContentsEqual(cppFile, outputCppFile);

        outputCppFile.delete();
    }

    private void testXmlToCode()
        throws Exception
    {
        final XmlToCodeExecutor exec = new XmlToCodeExecutor();
        exec.vmsPath = vmsPath;
        exec.sourceApiXmlFile = apiXmlFile;
        exec.outputApiXmlFile = templateApiXmlFile;

        final int processedFunctionsCount = exec.execute();

        if (expectedProcessedFunctionsCount != processedFunctionsCount)
        {
            throw new RuntimeException("Expected to process " + expectedProcessedFunctionsCount
                + " API functions but processed " + processedFunctionsCount);
        }
    }

    private void testCodeToXml()
        throws Exception
    {
        final CodeToXmlExecutor exec = new CodeToXmlExecutor();
        exec.vmsPath = vmsPath;
        exec.templateApiXmlFile = templateApiXmlFile;
        exec.outputApiXmlFile = generatedApiXmlFile;

        // This test should parse source files generated by testXmlToCode().
        exec.sourceFileExtraSuffix = Executor.OUTPUT_FILE_EXTRA_SUFFIX;

        final int processedFunctionsCount = exec.execute();

        if (expectedProcessedFunctionsCount != processedFunctionsCount)
        {
            throw new RuntimeException("Expected to process " + expectedProcessedFunctionsCount
                + " API functions but processed " + processedFunctionsCount);
        }
    }

    private void outputXmlVsOriginalXml()
        throws Exception
    {
        final File sortedApiXmlFile = Utils.insertSuffix(apiXmlFile, ".SORTED");

        final XmlSorter sorter = new XmlSorter();
        sorter.groupName = Executor.SYSTEM_API_GROUP_NAME;
        sorter.sourceApiXmlFile = apiXmlFile;
        sorter.outputApiXmlFile = sortedApiXmlFile;
        sorter.execute();

        checkTextFilesEqualIgnoringIndents(
            sortedApiXmlFile, generatedApiXmlFile);
    }

    //--------------------------------------------------------------------------

    private final File testPath;
    private final File vmsPath;
    private final File apiXmlFile;
    private final File templateApiXmlFile;
    private final File generatedApiXmlFile;
    private final File cppFile;
    private final File testPropertiesFile;

    private int expectedProcessedFunctionsCount;

    public Tests(File testPath)
    {
        this.testPath = testPath;
        this.vmsPath = new File(testPath + "/netoptix_vms");
        this.apiXmlFile = new File(testPath + "/api.xml");
        this.templateApiXmlFile = Utils.insertSuffix(apiXmlFile, ".TEMPLATE");
        this.generatedApiXmlFile = Utils.insertSuffix(apiXmlFile, ".FROM_CPP");
        this.cppFile = new File(vmsPath + "/appserver2/src/connection_factory.cpp");
        this.testPropertiesFile = new File(testPath + "/test.properties");

        readTestProperties();

        run("testXml", new Run() { public void run() throws Exception {
            testXml(); } });

        run("testSourceCode", new Run() { public void run() throws Exception {
            testSourceCode(); } });

        run("xmlToCode", new Run() { public void run() throws Exception {
            testXmlToCode(); } });

        run("codeToXml", new Run() { public void run() throws Exception {
            testCodeToXml(); } });

        run("outputXmlVsOriginalXml", new Run() { public void run() throws Exception {
            outputXmlVsOriginalXml(); } });

        printFinalMessage();
    }
}
